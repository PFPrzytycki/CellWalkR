---
title: "CellWalkR"
author: "Pawel F. Przytycki"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{CellWalkR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Getting Started

CellWalkR is an R package implementing the CellWalker method for combining 
scATAC-seq data with labels and other epigenetic data (see [paper](https://www.biorxiv.org/content/10.1101/847657v2) for details). 
This vignette shows
an example of running CellWalkR on a small set of scATAC-seq data to generate
a cellWalk object which can then be used to assign labels to cells as well as 
cell-type specific labels to bulk data.

```{r setup, message=FALSE, warning=FALSE}
library(CellWalkR)
```

```{r setseed, echo=FALSE}
set.seed(1)
```

First, load scATAC-seq data in the form of a cell-by-peak matrix and load the 
corresponding peaks into a GRanges object. CellWalkR can also take SnapATAC, 
ArchR, or Cicero data as input. See [additional vignette](Other_Data_Vignette.md) 
for how to load these data types.

```{r loadATACMat, eval=FALSE}
pathToMat <- system.file("extdata", "SamplePeakMat.mtx", package = "CellWalkR")
ATACMat <- Matrix::readMM(pathToMat)
pathToPeaks <- system.file("extdata", "SamplePeaks.txt", package = "CellWalkR")
peaks <- as(data.table::fread(pathToPeaks, header = FALSE)$V1, "GRanges")
```

Next, we compute cell-to-cell similarity in order to build edges in the
cell-to-cell portion of the graph. 

```{r cellEdges, message=FALSE}
cellEdges <- computeCellSim(ATACMat)
```

cellEdges is a cell-by-cell matrix of cell-to-cell similarity. Any matrix of 
cell similarity can be used.

```{r print_cellEdges}
cellEdges[1:5,1:5]
```

In order to generate label-to-cell edges, we need to define which genomic 
regions correspond to which genes. These could be promoters, gene bodies, or
any other definition. If a specific set of regions associated with genes 
isn't already known, the getRegions() function can be used to generate a 
mapping. This function can retreive hg38 and mm10 mappings. Other mappings
can be generated using TxDb objects or biomaRt. 

We'll use hg38 with Entrez identifiers in this example, using full gene bodies. 

```{r getRegions, message=FALSE}
regions <- getRegions(geneBody = TRUE, genome = "hg38", names = "Entrez")
```

regions is a GRanges object with a gene_id field. **This gene_id field needs to
match the genes (or other identifiers) in the labeling data**.

```{r print_getRegions}
head(regions)
```

Now we can load our first set of labeling data. If no labeling data is 
available, findMarkers() can be run on a set of scRNA-seq data. 

```{r labelGenes, eval=FALSE}
pathToLabels <- system.file("extdata", "SampleMarkers1.txt", package = "CellWalkR")
labelGenes <- data.table::fread(pathToLabels)
```

The labeling data should consist of at least two columns, gene names (or other
identifiers that match regions) and 
associated labels, with an optional third column for log-fold change in 
expression of that gene for that label.

```{r print_labelGenes}
head(labelGenes)
```

We then need to map between this data and the peaks in the scATAC-seq data.

```{r mapPeaksToGenes}
ATACGenePeak <- mapPeaksToGenes(labelGenes, ATACMat, peaks, regions)
```

With this mapping we can compute label-to-cell edges, a matrix where the number
of columns is the number of labels and the number of rows is the number of 
cells.

```{r computeLabelEdges}
labelEdges <- computeLabelEdges(labelGenes, ATACMat, ATACGenePeak)
head(labelEdges)
```

## Tuning Label Edges

Although we now have cell-to-cell edges and label-to-cell edges, we don't know 
how to correctly weight the two relative to each other. The tuneEdgeWeights
method will run CellWalker across a range of possible parameters and compute
cell homogeneity for each.
We make a list of labelEdges because there can be many of them, and sample down
to 1000 cells for faster computation. Edge weights can optionally be tuned in parallel.

```{r tuneEdgeWeights}
labelEdgesList <- list(labelEdges)
edgeWeights <- tuneEdgeWeights(cellEdges, 
                              labelEdgesList, 
                              labelEdgeOpts = 10^seq(1,7,1), 
                              sampleDepth = 1000)
```

We can see which parameter had the highest cell homogeneity:

```{r print-tuneEdgeWeights}
head(edgeWeights[order(edgeWeights$cellHomogeneity, decreasing = TRUE),])
```

And can generate a cellWalk object with this parameter. This object stores
the final influence matrix and can be used for downstream analysis.

```{r walkCells-Edges}
cellWalk <- walkCells(cellEdges, 
                     labelEdgesList, 
                     labelEdgeWeights = 1e+07)
```

## Adding Filters

We may have some bulk epigenetic data that can help filter down which peaks are
relevant to our analysis. We can tune weights on each filter to determine
how signficant it is to our data. For our example we have H3K4me3 data which
indicates active promoters. Thus we apply this filter permissively (setting 
filterOut=FALSE) and at the whole gene level (filterGene=TRUE) rather than just 
to overlaping peaks. 

```{r loadFilters, eval=FALSE}
pathToFilter <- system.file("extdata", "SampleFilter.bed", package = "CellWalkR")
filter <- data.table::fread(pathToFilter)
filter <- GRanges(filter$V1, IRanges(filter$V2, filter$V3))
```
```{r tuneFilterWeights}
filters <- list(filter)
labelGenesList <- list(labelGenes)
filterWeights <- tuneFilterWeights(cellEdges, 
                                  labelGenesList, 
                                  labelEdgesList, 
                                  labelEdgeWeights = 1e+07,
                                  ATACMat,
                                  ATACGenePeak,
                                  filters = filters,
                                  filterOut = c(FALSE),
                                  filterGene = c(TRUE),
                                  regions=regions, 
                                  sampleDepth = 1000)
filterWeights
```

We see that adding this filter improves performance. We can make a new cellWalk 
object using this filter:

```{r walkCells-Filters}
labelEdges <- computeLabelEdges(labelGenes, 
                               ATACMat, 
                               ATACGenePeak,
                               filters = filters, 
                               filterWeights = c(1),
                               filterOut = c(FALSE),
                               filterGene = c(TRUE),
                               regions = regions)
labelEdgesList <- list(labelEdges)
cellWalk <- walkCells(cellEdges, 
                     labelEdgesList, 
                     labelEdgeWeights = 1e+07)
```

## Downstream Analysis

Once we have created a cellWalk object, we can use it for downstream analysis.

Most directly, we can look at what labels are the most strongly linked to 
each cell. This is based on the maxiumum amount of label-to-cell influence in the
cell walk. Cell labeling can be used for numerous further downstream analyses 
such as cell-type specific peak calling.

```{r downstream-cellLabels}
head(cellWalk$cellLabels)
```

However, in actuality, labels are "fuzzy" meaning each cell actually has a distribution
of scores from each label. Thanks to this, we can examine how often labels are confused
for each other. The label threshold determines the minimum influence score a cell must 
get to be considered labeled. Plotting requires the packages ggplot2 and reshape2.

```{r installPlotting, eval=FALSE}
install.packages("ggplot2")
install.packages("reshape2")
```
```{r downstream-uncertainty}
cellWalk <- findUncertainLabels(cellWalk, labelThreshold = 0, plot = TRUE)
```

We can also directly examine label similarity by considering label-to-label 
influence.

```{r downstream-labelLabels}
cellWalk <- clusterLabels(cellWalk,  plot = TRUE)
```

Two-dimensional embeddings of cells can be a very helpful tool for understanding 
cell diversity. We can directly embed cell-to-cell influence scores. Importantly, 
this portion of the influence matrix is not used in establishing the labeling of
cells. Thus this can serve as distinct way to explore how labels were distributed
accross cells. Because of this, unlike with most scATAC-seq analysis pipelines,
clusters observed in this embedding may not directly correspond to labels. This 
can help understand cell diversity, as well as assist in identifying rare cell types.
In addition to ggplot2, embedding also requires the package Rtsne.

```{r installTSNE, eval=FALSE}
install.packages("Rtsne")
```
```{r downstream-plotCellsLabels}
cellWalk <- plotCells(cellWalk, labelThreshold = 0, seed = 1)
```

It is also possible to plot how strongly a single label influences each cell in the
embedding.

```{r downstream-plotCellsInf}
cellWalk <- plotCells(cellWalk, cellTypes = c("RG-div2"), seed = 1)
```

Furthermore, to analyze rare cell types, it can be helpful to only plot a subset of 
of all labels.

```{r downstream-plotCellsRare}
cellWalk <- plotCells(cellWalk, cellTypes = c("RG-early","tRG","vRG"), labelThreshold = 0, seed = 1)
```

A very powerful use for the cell walk is mapping data to labels via 
cell-to-label influence. For example, we can map enhancers to cell types.

```{r downstream-loadEnhancers, eval=FALSE}
pathToEnhancers <- system.file("extdata", "sampleEnhancers.bed", package = "CellWalkR")
sampleEnhancers <- data.table::fread(pathToEnhancers)
sampleEnhancers <- GRanges(sampleEnhancers$V1, 
                           IRanges(sampleEnhancers$V2, sampleEnhancers$V3))
```
```{r downstream-mapLabels}
mappedLabel <- labelBulk(cellWalk, 
                        sampleEnhancers[1:10], 
                        ATACMat, 
                        peaks)
mappedLabel
```

## Adding a Second Set of Labels

CellWalkR can be run on an arbitrary number of sets of labels and filters, each
with it's own weight. Filters can selectively be applied to some sets of labels
and not others. Here for example, we will add a second set of labels to which
the above filter does not apply.

```{r moreLabels-loaddata, eval=FALSE}
pathToLabelsB <- system.file("extdata", "SampleMarkers2.txt", package = "CellWalkR")
labelGenesB <- data.table::fread(pathToLabelsB)
```
```{r moreLabels-data}
ATACGenePeakB <- mapPeaksToGenes(labelGenesB, ATACMat, peaks, regions)
labelEdgesB <- computeLabelEdges(labelGenesB, ATACMat, ATACGenePeakB)
```

Now simply tune edge weights as before with a list of all label edges.

```{r moreLabels}
labelEdgesListB <- list(labelEdges, labelEdgesB)
edgeWeightsB <- tuneEdgeWeights(cellEdges, 
                               labelEdgesListB, 
                               labelEdgeOpts = 10^seq(4,7,1),
                               sampleDepth = 1000)
head(edgeWeightsB[order(edgeWeightsB$cellHomogeneity, decreasing = TRUE),])
```

We can then compute a new cell walk using the list of edges and a vector of 
optimal weights.

```{r moreLabels-walk}
cellWalkB <- walkCells(cellEdges, 
                      labelEdgesListB, 
                      labelEdgeWeights = c(1e+04, 1e+06))
```

